#!/bin/sh
##
# Usage key:
#   command <required> [optional]
#

##
# Function to facilitate creation of new aliases.
#
function aa () {
  if [ ! -f $BASH_KIT_ALIASES ]; then
    touch $BASH_KIT_ALIASES
  fi
  if [ $# -lt 2 ]; then
    echo "usage: add <alias> <command>"
    return
  fi 
  local command=$1
  shift 1
  alias="alias $command='$@'"
  read -p "Add alias: $alias?"
  printf "$alias\n" >> $BASH_KIT_ALIASES
  if [[ $# ]]; then
    echo "Alias added"
    source $BASH_KIT_ALIASES
    else
    echo "Failed to add alias"
  fi
}

##
# Simple recursive grep helper. Searches for <regexp pattern> recursively
# within the current dir. Optionally, allows context.
#
function grepr () {
  if [ $# -lt 1 ]; then
    echo "usage: grepr <regexp> [context]"
    return
  fi

  # Store the search string so we can manipulate it.
  local regexp=$1

  # Automatically escape certain characters.
  regexp="${regexp//(/\(}"
  regexp="${regexp//)/\)}"

  # Figure out if ack is available and if so use it.
  local binary=grep
  which ack > /dev/null 2>&1
  if [ $? == "0" ]; then
    binary=ack
  fi
  which ack-grep > /dev/null 2>&1
  if [ $? == "0" ]; then
    binary=ack-grep
  fi

  # Things required for grep.
  if [ $binary == 'grep' ]; then
    # grep needs spaces escaping.
    regexp="${regexp// /\W}"
    local options=$GREP_OPTIONS
  fi

  # Things required for ack.
  if [[ $binary == 'ack' || $binary == 'ack-grep' ]]; then
    local options=$ACK_OPTIONS    
  fi

  # Both grep and ack need brackets escaping.
  regexp="${regexp//(/\(}"
  regexp="${regexp//)/\)}"

  # If 3 parameters are passed, add the context option.
  if [ $# == 2 ]; then
    options="$options --context=$2"
  fi

  $binary "$regexp" $options
}

##
# Version Control System switcher.
#
# Usage:
#   vc [vcs]
#
function vc () {
  if [ $# == 1 ]; then
    export VC=$1
  fi
  echo $VC
}

##
# VCS agnostic add.
#
# Note: git add is completely different to bzr|cvs|svn add!
#
function add () {
  if [ $# == 0 ]; then
    echo "usage: add <file>"
    return
  fi
  $VC add $1
}

##
# VCS agnostic update.
#
function up () {
  case $VC in
    cvs )
      cvs update -dP $*
      ;;
    git )
      git pull origin master
      ;;
    * )
      $VC update $*
      ;;
  esac
}

##
# VCS agnostic commit with message.
#
function ci () {
  if [ $# -lt 1 ]; then
    echo "usage: ci <message>"
    return
  fi
  message="$1"
  shift 1
  $VC commit -m "$message" $*
  if [ "$VC" == 'git' ]; then
    BRANCH=`git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'`
    git push origin $BRANCH
  fi
}

##
# VCS agnostic diff.
#
# Usage:
#   dif [args]
#
function dif () {
  if [ $VC == 'cvs' ]; then
    cvs diff $CVS_DIFF_OPTIONS
  else
    $VC diff $*
  fi
}

##
# VCS agnostic status.
#
# Usage:
#   st [args]
#
function st () {
  $VC status $*
}

##
# VCS agnostic blame.
#
# Usage:
#   blame [args]
#
function blame () {
  if [ $VC == 'bzr' ]; then
    $VC blame --all $*
  else
    $VC blame $*
  fi
}

##
# Set up a git repo using the contents of the pwd.
#
# Usage:
#   gitsetup <repo>
#
function gitsetup () {
  # if an argument is not given use the directory name
  if [[ -n $1 ]]; then
    repo="$1"
  else
    repo=`basename "$PWD"`
  fi
  location="$REPO_LOCATION/$repo.git"
  git init
  git add .
  git commit -m "Initial commit."
  git remote add origin $REPO_SERVER:$location
  git push origin master
}

function gitmigrate () {
  git remote rm origin
  git remote add origin git@dev.fs:$1
  read -p "Add $1 to gitosis."
  ssh $SSH "ln -s /home/git/post-receive /home/git/repositories/$1.git/hooks/"
  push
}

##
# Allow a repository to be readable by git-daemon.
#
# Usage:
#   gitexport [repo]
#
function gitexport () {
  # if an argument is not given use the directory name
  if [[ -n $1 ]]; then
    repo="$1"
  else
    repo=`basename "$PWD"`
  fi
  ssh $REPO_SERVER "touch $REPO_LOCATION/$repo.git/git-daemon-export-ok"
}

##
# Quickly switch cvs logins.
#
function cvslogin () {
  if [ $# -lt 1 ]; then
    echo "cvslogin <username>"
    return
  fi
  export CVSROOT=":pserver:$1@cvs.drupal.org:/cvs/drupal-contrib"
  cvs login
}

##
# Interface to the CVS checkout command.
#
function cvsco () {
  if [ $# -lt 1 ]; then
    echo "cvsco <project-7.x-1.x-dev>"
    return
  fi
  $DRUSH_PATH dl --package-handler=cvs --cvscredentials=$CVS_USER $1
}

function vc_evaluate () {
  if vc_is_git; then
    echo "This is a git repo."
    return
  fi
  if vc_is_bzr; then
    echo "This is a bzr repo."
    return
  fi
  if vc_is_svn; then
    echo "This is an svn repo."
    return
  fi
  # if vc_is_cvs; then
  #   echo "This is a cvs repo."
  #   return
  # fi
}

function vc_is_git () {
  git branch &>/dev/null
}

function vc_is_bzr () {
  bzr status &>/dev/null
}

function vc_is_svn () {
  svn info &>/dev/null
}

# @todo: figure out a *fast* way to determine if a dir is a cvs repo.
#function vc_is_cvs () {}

##
# Add the post-receive hook into a project's repo.
#
function post-receive () {
  if [ $# -lt 1 ]; then
    echo "post-receive <project>"
    return
  fi
  ssh $SSH "ln -s ${REPO_LOCATION}post-receive ${REPO_LOCATION}repositories/$1.git/hooks/"
}

##
# List all repos on the main repo server.
#
function list () {
  ssh $SSH "ls -1 ${REPO_LOCATION}repositories"
}

##
# Clone a project from git.drupal.org
#
function dclone () { 
  git clone "git://git.drupal.org/projects/$1.git"
}

##
# Create a new development site.
# Assumes a drupal developer skeleton makefile dd.make in the current dir.
#
function dd () {
  MAKEFILE="${MAKEFILES}dd.make"
  dmake $MAKEFILE $1
  sql create drupal_$1
}

##
# Run a makefile for a given target. Should be used internally.
#
function dmake() {
  drush make $1 $2
}
